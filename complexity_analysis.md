Анализ сложности алгоритмов системы курсов

1. Алгоритм sort_courses_by_price (пузырьковая сортировка)

Временная сложность:
- Худший случай O(n²) когда массив отсортирован в обратном порядке
- Средний случай O(n²)
- Лучший случай O(n) когда массив уже отсортирован

Пространственная сложность:
- O(1) сортировка на месте не требует дополнительной памяти

Обоснование:
Алгоритм использует два вложенных цикла
Внешний цикл n итераций
Внутренний цикл n-i-1 итераций
Суммарно примерно n²/2 операций сравнения

2. Алгоритм find_course_by_name (бинарный поиск)

Временная сложность:
- O(log n) где n количество курсов
- Каждый шаг уменьшает область поиска вдвое

Пространственная сложность:
- O(n) для хранения отсортированной копии массива
- O(1) для самой работы алгоритма

Обоснование:
Алгоритм делит отсортированный массив пополам
На каждом шаге отбрасывает половину элементов
Для массива из 1000 элементов нужно около 10 сравнений

3. Алгоритм filter_students_by_domain (линейная фильтрация)

Временная сложность:
- O(n) где n количество студентов
- Каждый студент проверяется один раз

Пространственная сложность:
- O(n) в худшем случае если все студенты подходят
- O(1) если не считать результат

Обоснование:
Один проход по массиву студентов
Для каждого студента проверка условия O(1)

4. Алгоритм calculate_average_price

Временная сложность:
- O(n) где n количество курсов
- Суммирование цен всех курсов

Пространственная сложность:
- O(1) только переменные для суммы и счётчика

5. Алгоритм check_course_availability

Временная сложность:
- O(1) проверка длины списка студентов
- Константное время независимо от размера данных

Пространственная сложность:
- O(1) не требуется дополнительной памяти

Выводы:

1. Для небольших наборов данных (до 100 курсов) пузырьковая сортировка эффективна
2. Бинарный поиск оптимален для поиска в отсортированных данных
3. Линейные алгоритмы O(n) подходят для обработки студентов
4. Все алгоритмы имеют разумную сложность для учебной системы

Рекомендации:

1. Для больших данных заменить пузырьковую сортировку на быструю O(n log n)
2. Добавить кэширование результатов частых операций
3. Использовать индексацию для ускорения поиска